#!/bin/sh

usage() {
	echo "usage: Install one of the following pacakges"
	echo "usage: usbosx install usbmuxd"
}

parse_args() {
	# parse options
	FLAGS "$@" || exit $?
	eval set -- "${FLAGS_ARGV}"
}

# Default entry when no SUBACTION is given
cmd_default() {
	DEFINE_boolean force false 'force setting of gitflow branches, even if already configured' f
	DEFINE_boolean defaults false 'use default branch naming conventions' d
	parse_args "$@"
	
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		git_do init
	else
		# assure that we are not working in a repo with local changes
		git_repo_is_headless || require_clean_working_tree
	fi

	# running git flow init on an already initialized repo is fine
	if gitflow_is_initialized && ! flag force; then
		warn "Already initialized for gitflow."
		warn "To force reinitialization, use: git flow init -f"
		exit 0
	fi

	local branch_count
	local answer

    if flag defaults; then
        warn "Using default branch names."
    fi

	# add a main branch if no such branch exists yet
	local main_branch
	if gitflow_has_main_configured && ! flag force; then
		main_branch=$(git config --get gitflow.branch.main)
	else
		# Two cases are distinguished:
		# 1. A fresh git repo (without any branches)
		#    We will create a new main branch for the user
		# 2. Some branches do already exist
		#    We will disallow creation of new main branches and
		#    rather allow to use existing branches for git-flow.
		local default_suggestion
		local should_check_existence
		branch_count=$(git_local_branches | wc -l)
		if [ "$branch_count" -eq 0 ]; then
			echo "No branches exist yet. Base branches must be created now."
			should_check_existence=NO
			default_suggestion=$(git config --get gitflow.branch.main || echo main)
		else
			echo
			echo "Which branch should be used for bringing forth production releases?"
			git_local_branches | sed 's/^.*$/   - &/g'

			should_check_existence=YES
			default_suggestion="main"
			for guess in $(git config --get gitflow.branch.main) \
			             'master' 'main' 'production'; do
				if git_local_branch_exists "$guess"; then
					default_suggestion="$guess"
					break
				fi
			done
		fi
		
		printf "Branch name for production releases: [$default_suggestion] "
		if noflag defaults; then
			read answer
		else
			printf "\n"
		fi
		main_branch=${answer:-$default_suggestion}

		# check existence in case of an already existing repo
		if [ "$should_check_existence" = "YES" ]; then
			# if no local branch exists and a remote branch of the same
			# name exists, checkout that branch and use it for main
			if ! git_local_branch_exists "$main_branch" && \
				git_remote_branch_exists "origin/$main_branch"; then
				git_do branch "$main_branch" "origin/$main_branch" >/dev/null 2>&1
			elif ! git_local_branch_exists "$main_branch"; then
				die "Local branch '$main_branch' does not exist."
			fi
		fi

		# store the name of the main branch
		git_do config gitflow.branch.main "$main_branch"
	fi

	# Creation of HEAD
	# ----------------
	# We create a HEAD now, if it does not exist yet (in a fresh repo). We need
	# it to be able to create new branches.
	local created_gitflow_branch=0
	if ! git rev-parse --quiet --verify HEAD >/dev/null 2>&1; then
		git_do symbolic-ref HEAD "refs/heads/$main_branch"
		git_do commit --allow-empty --quiet -m "Initial commit"
		created_gitflow_branch=1
	fi

	# Creation of main
	# ------------------
	# At this point, there always is a main branch: either it existed already
	# (and was picked interactively as the production branch) or it has just
	# been created in a fresh repo


	# assert the gitflow repo has been correctly initialized
	gitflow_is_initialized

	# switch to main branch if its newly created
	if [ $created_gitflow_branch -eq 1 ]; then
		git_do checkout -q "$main_branch"
	fi

	# finally, ask the user for naming conventions (branch and tag prefixes)
	if flag force || \
	   ! git config --get gitflow.prefix.feature >/dev/null 2>&1 || 
	   ! git config --get gitflow.prefix.release >/dev/null 2>&1 || 
	   ! git config --get gitflow.prefix.hotfix >/dev/null 2>&1 || 
	   ! git config --get gitflow.prefix.support >/dev/null 2>&1 || 
	   ! git config --get gitflow.prefix.versiontag >/dev/null 2>&1; then
		echo
		echo "How to name your supporting branch prefixes?"
	fi

	local prefix

	# Feature branches
	if ! git config --get gitflow.prefix.feature >/dev/null 2>&1 || flag force; then
		default_suggestion=$(git config --get gitflow.prefix.feature || echo feature/)
		printf "Feature branches? [$default_suggestion] "
		if noflag defaults; then
			read answer
		else
			printf "\n"
		fi
		[ "$answer" = "-" ] && prefix= || prefix=${answer:-$default_suggestion}
		git_do config gitflow.prefix.feature "$prefix"
	fi

	# Release branches
	if ! git config --get gitflow.prefix.release >/dev/null 2>&1 || flag force; then
		default_suggestion=$(git config --get gitflow.prefix.release || echo release/)
		printf "Release branches? [$default_suggestion] "
		if noflag defaults; then
			read answer
		else
			printf "\n"
		fi
		[ "$answer" = "-" ] && prefix= || prefix=${answer:-$default_suggestion}
		git_do config gitflow.prefix.release "$prefix"
	fi


	# Hotfix branches
	if ! git config --get gitflow.prefix.hotfix >/dev/null 2>&1 || flag force; then
		default_suggestion=$(git config --get gitflow.prefix.hotfix || echo hotfix/)
		printf "Hotfix branches? [$default_suggestion] "
		if noflag defaults; then
			read answer
		else
			printf "\n"
		fi
		[ "$answer" = "-" ] && prefix= || prefix=${answer:-$default_suggestion}
		git_do config gitflow.prefix.hotfix "$prefix"
	fi


	# Support branches
	if ! git config --get gitflow.prefix.support >/dev/null 2>&1 || flag force; then
		default_suggestion=$(git config --get gitflow.prefix.support || echo support/)
		printf "Support branches? [$default_suggestion] "
		if noflag defaults; then
			read answer
		else
			printf "\n"
		fi
		[ "$answer" = "-" ] && prefix= || prefix=${answer:-$default_suggestion}
		git_do config gitflow.prefix.support "$prefix"
	fi


	# Version tag prefix
	if ! git config --get gitflow.prefix.versiontag >/dev/null 2>&1 || flag force; then
		default_suggestion=$(git config --get gitflow.prefix.versiontag || echo "")
		printf "Version tag prefix? [$default_suggestion] "
		if noflag defaults; then
			read answer
		else
			printf "\n"
		fi
		[ "$answer" = "-" ] && prefix= || prefix=${answer:-$default_suggestion}
		git_do config gitflow.prefix.versiontag "$prefix"
	fi

	# GitHub features configuration
	if ! git config --get gitflow.github.pullrequest >/dev/null 2>&1; then
		default_suggestion=$(git config --get gitflow.github.pullrequest || echo "no")
		printf "Want to use GitHub command line features? [$default_suggestion] "
		read answer
		[ "$answer" = "yes" ] && prefix="yes" || prefix="no"
		git_do config gitflow.github.pullrequest "$prefix"
	fi

	# Login at GitHub with 'gh' if user chose GitHub command line features
	if [ "$(git config --get gitflow.github.pullrequest)" = "yes" ]; then
		# Check if gh 'github command line' is installed
		if [ $(which gh) != "" ]; then
			echo "To finish the configuration, login with your GitHub account."
			echo "You will now be using GitHub 'gh' software..."
			echo "\n"
			gh auth login
		else
			echo "You need to install 'gh' (GitHub command line software)"
			echo "and login with your account using the following command:"
			echo "\n"
			echo "  gh auth login"
			exit 1
		fi
	fi


	# TODO: what to do with origin?
}

cmd_help() {
	usage
	exit 0
}
